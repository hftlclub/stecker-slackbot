\subsection{Anforderungsanalyse mittels Use-Case-Betrachtung}
% TODO: Struktur der Überschriften ändern, diese hat nur einen 
% Unterpunkt und passt thematisch nicht

Entsprechend der Anwendungsfälle aus Kapitel 2 lassen sich folgende Einschränkungen definieren:

\begin{itemize}
    \item der Bot soll weder intelligent noch lustig sein
    \item der Bot soll nicht ständig Nachrichten verfassen (siehe Auslöser im Usecase-Diagramm)
    \item der Bot soll nicht nur auf Slack beschränkt sein
\end{itemize}

Neben anderen möglichen Einsatzmöglichkeiten zur Mensch-Maschine-Interaktion (siehe \cite{PanConversationalInterfacesFuture2017} und \cite{GruensteinConversationalInterfaces2009}) dient der für dieses Projekt zu erstellende Bot als \enquote{Transaktionsbot} im Sinne einer Automatisierung der Datenbankabfragen. Da der Entwurf der Datenbank auch zum Projekt gehört, wird der ebenfalls zu erstellende Chatbot die einzige Schnittstelle zu den Endnutzern\footnote{in Abgrenzung zum Administrator, der z.B. direkt per Kommandozeile auf die Datenbank zugreift} bieten. Eine zukünftige Erweiterung um weitere Schnittstellen ist dabei nicht ausgeschlossen.

\subsubsection{Interaktion über Slack}

Es werden folgende Befehle für die Interaktion definiert.

\begin{table}[H]
\centering
\begin{tabular}{l|l}
  \textbf{Befehl }& \textbf{Bedeutung }\\
 \hline
% für vergessliche Leute
 zeige Schicht & zeigt die nächste Schicht für die aufrufende Person an \\
 zeige Schichten & zeigt alle zukünftigen Schichten für die aufrufende Person an \\
 zeige alle Schichten & zeigt einen Schichtplan an, welcher alle Mitglieder enthält \\
 
% jedes Mitglied muss pro Jahr mindestens x mal an die Bar
 zeige Anzahl Schichten & zeigt die geleisteten Schichten für dieses Jahr an \\
 zeige Anzahl alte Schichten & zeigt die geleisteten Sichten für letztes Jahr an \\
 
% zum Anzeigen der Auswahl an welchen man teilnehmen  möchte
 zeige Termine & zeigt alle kommenden Termine $t_i$ an \\
 zeige Veranstaltungen & zeigt alle zukünftigen Veranstaltungen $v_i$ an ($V \subseteq T$) \\
 zeige Sitzungen & zeigt alle zukünftigen Sitzungen $s_i$ an ($S \subseteq T$) \\
 
% für Termin eintragen
 nehme Teil an $t_i$ & trägt den aufrufenden Nutzer als Teilnehmer für $t_i$ ein \\
 nehme nicht Teil an $t_i$ & trägt den aufrufenden Nutzer für $t_i$ aus\\

 % Utilities
 hilf mir & zeigt alle verfügbaren Kommandos an \\
 danke & bricht die aktuelle Konversation ab \\
\end{tabular}
\caption{Befehle zur Chatbotinteraktion}
\label{tab:chatbotinteraktion}
\end{table}


Die Befehle in \autoref{tab:chatbotinteraktion} folgen einem vereinfachtem Schema natürlicher Sprache: \texttt{<Prädikat (Imperativ)> <Subjekt>}. Die Struktur der Befehle soll dabei einfach zu merken, auf menschlicher Sprache basierend und auch auf mobilen Geräten mit wenig Tipparbeit verwendbar sein. Bei einem optionalen Einsatz einer Spracherkennung sind auch komplexere Satzkonstruktionen möglich, für den hier zu erfüllenden Zweck genügt das Schema aus \texttt{<Befehl> <Objekt> <Filter>}. Wie in \cite{ZueConversationalinterfacesadvances2000} beschrieben, weicht die Art der Kommunikation von Mensch-zu-Mensch und Mensch-zu-Bot voneinander ab, worauf bei der Definition der Interaktionsbefehle geachtet wurde. Es ist nach Ansicht der Autoren wenig sinnvoll, einen Bot zu entwickeln, der durch den Zugriff auf große Datenmengen den Eindruck von Intelligenz vermittelt, die aber durch ihre Begrenzung dem Nutzer keinen Mehrwert bietet. Der hier entwickelte Bot verfügt bewusst über ein begrenztes Vokabular, so dass er nur die vom Nutzer gewünschten Informationen liefert; die Kenntnis der Befehle obliegt dem Nutzer.

Aus den in \autoref{tab:chatbotinteraktion} definierten Befehlen wurden die Aktivitätsdiagramme \autoref{img:activity-zeige} und \autoref{img:activity-teilnahme} erstellt, um die Reihenfolge der Interaktion besser zu strukturieren.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{../docs/uml/activity-zeige.png}
    \includegraphics[width=0.9\textwidth]{../docs/uml/activity-zeige2.png}
    \caption{Aktivitätsdiagramme zum Anzeigen von Terminen}
    \label{img:activity-zeige}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{../docs/uml/activity-teilnahme.png}
    \caption{Aktivitätsdiagramm zur Teilnahme an Terminen}
    \label{img:activity-teilnahme}
\end{figure}


Für die Befehle können auch Sätze gebildet werden, welche nachfolgend aufgeführt werden. Diese können Kontextbezogen sein, sodass sich der Bot ähnlich wie ein natürlicher Gesprächspartner verhält. Ein Beispiel hierfür ist in \autoref{tab:satzinteraktion} zu sehen.

\begin{table}[H]
\centering
\begin{tabular}{l|l}
\textbf{Satz} & \textbf{Bedeutung }\\
 \hline
Wann ist der nächste Termin? & zeigt den nächsten Termin an \\
Trag mich ein. & \makecell{trägt den Aufrufer für den Termin ein, wenn nur eine\\ Schicht vorhanden ist / fragt nach, in welche Schicht\\ der Aufrufer eingetragen werden soll, wenn mehr als\\ eine Schicht vorhanden ist} \\
\end{tabular}
\caption{natürliche Interaktion}
\label{tab:satzinteraktion}
\end{table}

Durch das Beispiel wird offensichtlich, dass der Bot den Kontext, in dem sich die Unterhaltung befindet, speichern muss. Dies ist pro Konversation, demnach pro Nutzer durchzuführen. Die Autoren gehen davon aus, dass eine Konversation nur einen Kontext besitzt. Es werden dadurch Konversationen ausgeschlossen, welche zwei Themen besitzen und diese sporadisch oder unvorhersehbar ändern.

Sollte der Satz \textit{Trag mich ein.} ohne Kontext geäußert werden, so soll keine Aktion durchgeführt werden. Da der Bot einer Konversation beiwohnen könnte, welche mit einem anderen Nutzer geführt wird, ist keine Aktion erforderlich oder gewünscht. Sollte der Bot jedoch zuvor den Satz \textit{Wann ist der nächste Termin?} aufgreifen, so soll er sich, wie eine natürliche Person, angesprochen fühlen und darauf reagieren. Weiterhin ist nun ein Kontext vorhanden, wodurch der nächste Satz eine Bedeutung erhält und nicht mehr ignoriert werden darf.


Die Autoren entschieden sich weitere Befehle einzuführen, die den Bot natürlich wirken lassen sollen. Diese können in \autoref{tab:natuerlicheinteraktion} eingesehen werden. Weiterhin werden die Sätze, auf die reagiert werden soll, in der EBNF dargestellt.
% ACRONYM EBNF

\texttt{V = "Veranstaltungen"}\\
\texttt{T = "Termine"}\\
\texttt{S = "{}Sitzungen"}

\texttt{Frage1 = "Kann mir \{irgend\}jemand sagen" $|$ "Weiß \{irgend\}jemand" $|$ "Wer weiß" $|$ "Wieso sagt mir niemand"}\\
\texttt{Apell1 = "{}Sag\{e\} mir endlich" $|$ "Jetz\{t\} sag\{e\} schon"}\\
\texttt{Frage2 = "Wann haben wir die nächsten" $|$ "Wann sind die nächsten"}

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|p{5cm}|X|}
	\hline
	\textbf{Satz} & \textbf{Antwort} \\
	\hline
	''Bob?'' & @\texttt{<Aufrufer>} Wie kann ich dir helfen? Mit \texttt{hilfe} zeige ich dir meine Hilfe. \\
	\hline
	{Frage1 '', wann ich Bardienst habe?'' $|$ Apell1 '', wann ich Bardienst habe'' ''.''$|$''!''} & @\texttt{<Aufrufer>} Dein nächster Bardienst ist am \texttt{<Datum>} von \texttt{<Beginn>} bis \texttt{<Ende>}.\\
	\hline
	Frage2 V$|$S$|$T ''?'' & @\texttt{<Aufrufer>} Die nächsten 5 \texttt{<V$|$S$|$T>} finden an folgenden Daten statt: \texttt{<Daten und Sichten>}\\
	\hline
	''Wann finden die nächsten '' V$|$S$|$T ''statt?'' & Die nächsten 5 \texttt{<V$|$S$|$T>} finden an folgenden Daten statt: \texttt{<Daten und Sichten>}\\
	\hline
	''Wird noch jemand für die nächste '' V '' gebraucht?'' &  Folgende Schichten benötigen noch Teilnehmer: \texttt{<Schicht>} \texttt{<Anzahl>} \\
	\hline
\end{tabularx}
\caption{natürliche Interaktion}
\label{tab:natuerlicheinteraktion}
\end{table}




\subsection{Datenbankschema}

Das Datenbankschema soll laut Anforderung unabhängig von einem spezifischen Chatbot nutzbar sein. Falls ein Chatbot ausgetauscht oder andere Interaktionsmethoden hinzugefügt werden, darf die Datenbank entsprechend keine Abhängigkeiten besitzen. Es wird deshalb ein Datenbankschema angelegt, welches nur die Terminverwaltung abbildet und anschließend eine Erweiterung hinzugefügt, welche die notwendigen Schlüssel auf die verwendete Plattform abbildet.

Die Autoren haben die Struktur der derzeitigen manuellen Terminverwaltung erfasst und daraus ein Schema entworfen. 
Das im Verlauf des Entwurfsprozesses spezifizierte Datenbankschema basiert auf in diesem Kontext wichtigen Begriffen, welche im Folgenden näher erläutert werden.

Jeder Termin hat eine Bezeichnung, wie beispielsweise eine Weihnachtsfeier, Sitzung oder ein Afterwork. Diese Bezeichnungen werden Termintypen genannt und können mehr als einmal auftreten, wobei die Bezeichnungen nach deren Festlegung nicht direkt Terminen zugeordnet werden müssen. So kann eine Bezeichnung Weihnachtsfeier eingeführt werden, diese jedoch noch nicht geplant sein.

Weiterhin gibt es Zeitpunkte oder Zeitspannen, zu denen Termine stattfinden. Der Begriff Termin legt jedoch nicht fest, ob es sich um eine Zeitspanne oder einen Zeitpunkt handelt. So kann der Beginn einer Sitzung festgelegt werden, deren Ende jedoch nicht. Eine Andere Sicht auf Termine wäre die planmäßige Dauer eines Afterworks, wobei der Anfang und ein voraussichtliches Ende bekannt sind.

Wenn ein Termin festgelegt wird und dieser häufiger als einmal auftreten kann, ist es möglich, dass auch die Zeitspannen und Zeitpunkte mehr als einmal auftreten. Ein Afterwork beginnt laut den bekannten Informationen immer 19:00 Uhr, wobei zwei Schichten geplant sind, da die Mitglieder nicht über den ganzen Abend Bardienst haben wollen. Die erste Schicht dauert zwei Stunden, endet demnach gegen 21:00 Uhr, während die zweite Schicht 21:00 Uhr beginnt und meist bis 23:00 geht. Der Bardienst der letzten Schicht kann nach eigenem Ermessen festlegen, ob die Bar später schließt oder nicht. Für die Verwaltung ist letzteres jedoch nicht relevant.

Die Mitglieder sollen weiterhin die Möglichkeit haben, sich in diese Schichten einzutragen. Es muss deshalb eine Zuordnung der Schichten eines Termins und den Nutzern geben. 


Um die Anforderungen in einer Datenbank modellieren zu können, wurde ein Schema gemäß \autoref{img:db-schema} erstellt. Das Datenbankschema wurde gemäß der 3. Normalform (siehe \cite{CoddRelationalModelData1970}) erstellt. Dadurch ergeben sich sich Vorteile hinsichtlich Integrität und Datenzugriffszeit durch die Vermeidung redundanter Daten sowie der eindeutigen Zuordnung von Primärschlüsseln zu Tabellen (Konsistenz). Ein weiterer Vorteil der 3. Normalform ist die im Verhältnis zur 1. und 2. Normalform bessere Erweiterbarkeit, da alle Datensätze thematisch getrennt in jeweils eigenen Tabellen stehen (z.B. Trennung von Nutzer und SlackNutzer). 
Für den Einsatz als von weiteren Daten isolierter SlackBot wäre ein DB-Modell in 1. oder 2. Normalform aufgrund einfacheren Aufbaus und weniger nötigen Lesezugriffen vorzuziehen, wurde aber hinsichtlich der gewünschten Integration in weitere Anwendungen in Form der 3. Normalform erstellt.

Die strikte Aufteilung der Daten in den Tabellen bildet auch die Ebenen der verschieden Lebenszyklen der Datensätze ab, wobei hier zwischen langsam, mittel und schnell unterschieden werden konnte. Diese in \autoref{tab:db-speed} ersichtliche Unterscheidung basiert auf den relativen Unterschieden der Speicherfrequenz der Datensätze und ist daher nicht mit absoluten Werten zu bemessen. Beispielsweise ändern sich die Datensätze in der Tabelle NutzerSchicht erwartungsgemäß öfter als in der Tabelle SlackNutzer.

\begin{table}[H]
    \begin{tabularx}{0.9\columnwidth}{|l|X|X|}
    \hline
    \textbf{Datenspeicher} & \textbf{Beschreibung} & \textbf{Tabellen} \\
    \hline
    langsam & Daten werden selten geschrieben aber lange gespeichert & Nutzer, SlackNutzer, TerminTyp \\
    \hline
    mittel & Kombination schneller und langsamer Daten & Termin, Schicht \\
    \hline
    schnell & Daten werden oft geschrieben und relativ kurz gespeichert & NutzerSchicht, TerminSchicht \\
    \hline
    \end{tabularx}
    \caption{Vergleich der \enquote{Geschwindigkeiten} der Daten}
    \label{tab:db-speed}
\end{table}

Aktuelle Datenbankverwaltungssysteme wie MySQL, PostgreSQL und MariaDB bieten eine Query-Cache\footnote{siehe u.a. \url{https://dev.mysql.com/doc/refman/5.7/en/query-cache.html}} zum Beschleunigen der Lesezugriffe. Gemäß der hier vorgenommenen Unterteilung sind \enquote{schnelle} Daten besonders für den Cache-Einsatz geeignet, da auf diese am meisten Zugriffe erfolgen. 

Der Termintyp eines Termins wurde in eine extra Tabelle ausgelagert, da dieser mehrfach auftreten kann und deshalb redundant ist. Ein Termin muss eindeutig identifiziert werden können, weshalb eine ID eingeführt wird. Weiterhin erhält ein Termin ein Datum, welches den Tag des Beginns enthält. Ein Termintyp kann angelegt werden, ohne einem Termin zugeordnet zu sein, jedoch auch beliebig vielen Terminen zugeordnet werden, weshalb die Kardinalität \texttt{1 : 0..*} sein muss.

Schichten erhalten ebenfalls eine eigene Tabelle, da diese sonst redundante Informationen einführen würden. Um eine Schicht mit einem Termin zu verbinden, muss eine Zuordnung erfolgen, weshalb eine Tabelle Terminschicht eingeführt wird. Über diese sind Termine, deren Namen und Schichten eindeutig identifizierbar. Es sollen Schichten angelegt werden können, ohne diese direkt Terminen bzw. der Terminschichttabelle zuweisen zu müssen, jedoch sollen Schichten beliebig vielen Terminen zugeordnet werden können. Die Kardinalität muss deshalb \texttt{1 : 0..*} zwischen Schicht und Terminschicht sein. Da ein Termin mehrere Schichten haben kann, demnach mehrfach in der Terminschichttabelle stehen kann und mindestens eine Zeit bzw. Schicht festgelegt haben muss, ist die Kardinalität zwischen Termin und Terminschicht \texttt{1 : 1..*}.

Nutzer erhalten ebenfalls eine eigene Tabelle mit einer ID. Die Nutzer müssen anschließend zu Terminschichten, d.h. zu eindeutigen Zeitspannen oder Zeitpunkten zugeordnet werden, wodurch eine Zuordnungstabelle Nutzerschicht benötigt wird. Da sich ein Nutzer in mehrere Schichten eintragen kann, jedoch auch keine Schicht belegt haben muss, ist die Kardinalität zwischen Nutzer und Nutzerschicht \texttt{1 : 0..*}. Eine Terminschicht muss keine Zuordnung zu einem Nutzer haben. Dies ist der Fall, wenn sich kein Nutzer für eine Schicht eintragen ließ. Die Kardinalität zwischen Terminschicht und Nutzerschicht ist dementsprechend ebenfalls \texttt{1 : 0..*}.

Die Zuordnung zu den verwendeten Chatplattformen ist nicht Teil der Terminverwaltung, soll jedoch nicht ausgelassen werden, weshalb eine Tabelle \texttt{<Plattform>}nutzer für jede Plattform angelegt werden kann, welche die IDs der Nutzer zu den Namen innerhalb einer Plattform zuordnet. Ein Nutzer einer Plattform ist hierbei immer eindeutig einem internen Nutzer zugeordnet. Ein interner Nutzer muss jedoch nicht Mitglied jeder Plattform sein. Es ist denkbar, dass sich ein Nutzer auf einer bestimmten Plattform mehr als einen Account anlegt und diesen mit dem intern eindeutigen Nutzer verbinden möchte. Dieser Fall soll nicht ausgeschlossen werden, weshalb die Kardinalität zwischen \texttt{<Plattform>}nutzer und Nutzer \texttt{0..* : 1} betragen muss.

Die Umsetzung der vorgestellten Informationen ist in \autoref{img:db-schema} ersichtlich.


% Hier das DB-Schmea rein und eine Fremdschlüsseltabelle für die Slack-Nutzernamen und bla

\begin{figure}[htbp]
    \includegraphics[width=\textwidth]{../docs/uml/Steckerbot-DB.png}
    \caption{Schema der Termin-Datenbank}
    \label{img:db-schema}
\end{figure}


\subsection{Kommunikationsschnittstellen}

Die kommunikation zwischen der Datenbank und dem Chatbot erfolgt auf dem gleichen Host, weshalb keine besonderen Fälle beachtet werden müssen. Der Kommunikationspfad zwischen dem Chatbot und Slack wird jedoch über ein Hochschulnetzwerk durchgeführt. In diesem sind in das Netzwerk des Clubs nur die Ports 80 und 443 freigegeben. Ausgehend ????????????????? doppeltes NAT aber Webseiten ok

Aus diesem Grund muss der Chatbot sich als Client mit Slack verbinden und darf keine Serveranwendung sein, welche ein Polling implementiert.

% vllt Grafik einfügen?


TODO: ERWEITERN
Slack hat eine option globale UIDs zum bot durchzuleiten. nützlich, wenn mehrere Workspaces genutzt werden - ist das der fall? ferdi fragen.
